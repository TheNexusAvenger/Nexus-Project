{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nexus-Project Nexus Project simplifies requiring resources in Roblox Lua. Using require in Roblox typically involves numerous WaitForChild calls, such as: local Script1 = require ( game . Workspace : WaitForChild ( \"Project\" ): WaitForChild ( \"Script1\" )) local Script2 = require ( game . Workspace : WaitForChild ( \"Project\" ): WaitForChild ( \"Subfolder1\" ): WaitForChild ( \"Script2\" )) local Script3 = require ( game . Workspace : WaitForChild ( \"Project\" ): WaitForChild ( \"Subfolder2\" ): WaitForChild ( \"Script3\" )) local Part1 = game . Workspace : WaitForChild ( \"Project\" ): WaitForChild ( \"Part\" ) ... Nexus Project is designed to simplify this, similar to imports. local Project = NexusProject . new ( game . Workspace : WaitForChild ( \"Project\" )) local Script1 = Project : GetResource ( \"Script1\" ) local Script2 = Project : GetResource ( \"Subfolder1.Script2\" ) local Script3 = Project : GetResource ( \"Subfolder2.Script3\" ) local Part1 = Project : GetResource ( \"Part1\" ) ...","title":"Home"},{"location":"#nexus-project","text":"Nexus Project simplifies requiring resources in Roblox Lua. Using require in Roblox typically involves numerous WaitForChild calls, such as: local Script1 = require ( game . Workspace : WaitForChild ( \"Project\" ): WaitForChild ( \"Script1\" )) local Script2 = require ( game . Workspace : WaitForChild ( \"Project\" ): WaitForChild ( \"Subfolder1\" ): WaitForChild ( \"Script2\" )) local Script3 = require ( game . Workspace : WaitForChild ( \"Project\" ): WaitForChild ( \"Subfolder2\" ): WaitForChild ( \"Script3\" )) local Part1 = game . Workspace : WaitForChild ( \"Project\" ): WaitForChild ( \"Part\" ) ... Nexus Project is designed to simplify this, similar to imports. local Project = NexusProject . new ( game . Workspace : WaitForChild ( \"Project\" )) local Script1 = Project : GetResource ( \"Script1\" ) local Script2 = Project : GetResource ( \"Subfolder1.Script2\" ) local Script3 = Project : GetResource ( \"Subfolder2.Script3\" ) local Part1 = Project : GetResource ( \"Part1\" ) ...","title":"Nexus-Project"},{"location":"contributing/","text":"Contributing Bugs and requests can be made through issues. Pull requests are open, but will only be accepted if they have the following: 1. A reason to be pulled. 2. Follow the existing coding standards (tabs, PascalCase, etc). 3. Have the appropriate unit tests as examples. This is mainly for new utilities. 4. Comments are included. Pulling Into Studio The format of this repository is based on Rojo by LPGhatguy . Any other tools that follow the same file structure will work. Exporting From Studio No public tool is currently provided for exporting Rojo projects from Roblox Studio. \"Nexus Project Syncer\" currently exists as an internal tool but will require significant work done before it can be released. The end goal of that project will be to replace Rojo while still being compatible. This functionality is expected to be added to Rojo in the near future.","title":"Contributing"},{"location":"contributing/#contributing","text":"Bugs and requests can be made through issues. Pull requests are open, but will only be accepted if they have the following: 1. A reason to be pulled. 2. Follow the existing coding standards (tabs, PascalCase, etc). 3. Have the appropriate unit tests as examples. This is mainly for new utilities. 4. Comments are included.","title":"Contributing"},{"location":"contributing/#pulling-into-studio","text":"The format of this repository is based on Rojo by LPGhatguy . Any other tools that follow the same file structure will work.","title":"Pulling Into Studio"},{"location":"contributing/#exporting-from-studio","text":"No public tool is currently provided for exporting Rojo projects from Roblox Studio. \"Nexus Project Syncer\" currently exists as an internal tool but will require significant work done before it can be released. The end goal of that project will be to replace Rojo while still being compatible. This functionality is expected to be added to Rojo in the near future.","title":"Exporting From Studio"},{"location":"why-nexus-project/","text":"Why Nexus Project Simplified Requires The primary goal of Nexus Project is to reduce the complexity of requiring ModuleScripts . Using a Folder in ReplicatedStorage with a set of ModuleScripts and other instances would look like this: --[[ Without Nexus Project. --]] local ClientModules = game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"ClientModules\" ) local UICreator = require ( Project : WaitForChild ( \"UICreator\" )) local ColorUtil = require ( Project : WaitForChild ( \"Util\" ): WaitForChild ( \"ColorUtil\" )) local TweenUtil = require ( Project : WaitForChild ( \"Util\" ): WaitForChild ( \"TweenUtil\" )) local DefaultColors = require ( Project : WaitForChild ( \"Data\" ): WaitForChild ( \"UI\" ): WaitForChild ( \"DefaultColors\" )) --[[ With Nexus Project. --]] --Create the base project. local NexusProject = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"NexusProject\" )) local Project = NexusProject . new ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"ClientModules\" )) --Require several modules. local UICreator = Project : GetResource ( \"UICreator\" ) local ColorUtil = Project : GetResource ( \"Util.ColorUtil\" ) local TweenUtil = Project : GetResource ( \"Util.TweenUtil\" ) local DefaultColors = Project : GetResource ( \"Data.UI.DefaultColors\" ) Non-Module Resources Along with ModuleScripts , other data can be retrieved or stored. This is useful for other Roblox instances, as well as configurable items or constants. --Create the base project. local NexusProject = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"NexusProject\" )) local Project = NexusProject . new ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"ClientModules\" )) --Store some values. Project : SetResource ( \"Constants.ConfirmColor\" , Color3 . new ( 0 , 1 , 0 )) Project : SetResource ( \"Constants.CancelColor\" , Color3 . new ( 1 , 0 , 0 )) --Get the values. local BaseButtonObject = Project : GetResource ( \"Base.UI.Buttton\" ) local ConfirmColor = Project : GetResource ( \"Constants.ConfirmColor\" ) local CancelColor = Project : GetResource ( \"Constants.CancelColor\" ) local ConfirmButtonBase , CancelButtonBase = BaseButtonObject : Clone (), BaseButtonObject : Clone () ConfirmButtonBase . BackgroundColor3 , CancelButtonBase . BackgroundColor3 = ConfirmColor , CancelColor Custom Base Paths A project may store objects in different places. All of these can be combined into a single project. --Create the base project. local NexusProject = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"NexusProject\" )) local Project = NexusProject . new ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"ClientModules\" )) --Add external path bases. Project : CreatePathLink ( \"Workspace\" , game : GetService ( \"Workspace\" )) Project : CreatePathLink ( \"Common\" , game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"CommonModules\" )) --Get several resources. local Baseplate = Project : GetResource ( \"Workspace.Baseplate\" ) local Terrain = Project : GetResource ( \"Workspace.Terrain\" ) local CFrameTweenUtil = Project : GetResource ( \"Common.Util.CFrameTweenUtil\" ) Path Redirecting For public libraries, modules may need to be moved to make it more clear, or to refactor code. --Create the base project. local NexusProject = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"NexusProject\" )) local Project = NexusProject . new ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"ClientModules\" )) --Redirect resources. Project : SetResource ( \"ColorUtil\" , Project : GetResource ( \"Util.ColorUtil\" )) Project : SetResource ( \"TweenUtil\" , Project : GetResource ( \"Util.TweenUtil\" )) Cyclic Dependency Detection and Correction Cyclic dependency (A requires B, B requires A) happens a lot and can be hard to detect. Using \"contexts\", detecting them can be pretty easy. For example, assume there are the following scripts: --ReplicatedStorage/Client local NexusProject = require ( script : WaitForChild ( \"NexusProject\" )) local Client = NexusProject . new ( script ) return Client --ReplicatedStorage/Client/Util/ColorUtil local Client = require ( script . Parent . Parent ): GetContext ( script ) local TweenUtil = Client : GetResource ( \"Util.TweenUtil\" ) local ColorUtil = {} return ColorUtil --ReplicatedStorage/Client/Util/TweenUtil local Client = require ( script . Parent . Parent ): GetContext ( script ) local TeleportUtil = Client : GetResource ( \"Util.TeleportUtil\" ) local TweenUtil = {} return TweenUtil --ReplicatedStorage/Client/Util/TeleportUtil local Client = require ( script . Parent . Parent ): GetContext ( script ) local ColorUtil = Client : GetResource ( \"Util.ColorUtil\" ) local TeleportUtil = {} return TeleportUtil Would result in the following warning: A dependency loop exists : Util . ColorUtil Util . TweenUtil Util . TeleportUtil Util . ColorUtil Use NexusProject :: SetResource or NexusProjectContext :: SetContextResource to allow the loop to end without having to load the resources . The last line shows how it can be mitigated. All 3 modules end up in a deadlock since each need each other to finish loading to continue. The quick way to resolve this is to set one of the resources so the others can finish loading. --ReplicatedStorage/Client/Util/TweenUtil local Client = require ( script . Parent . Parent ): GetContext ( script ) local TweenUtil = {} Client : SetContextResource ( TweenUtil ) local TeleportUtil = Client : GetResource ( \"Util.TeleportUtil\" ) return TweenUtil","title":"Why Nexus Project"},{"location":"why-nexus-project/#why-nexus-project","text":"","title":"Why Nexus Project"},{"location":"why-nexus-project/#simplified-requires","text":"The primary goal of Nexus Project is to reduce the complexity of requiring ModuleScripts . Using a Folder in ReplicatedStorage with a set of ModuleScripts and other instances would look like this: --[[ Without Nexus Project. --]] local ClientModules = game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"ClientModules\" ) local UICreator = require ( Project : WaitForChild ( \"UICreator\" )) local ColorUtil = require ( Project : WaitForChild ( \"Util\" ): WaitForChild ( \"ColorUtil\" )) local TweenUtil = require ( Project : WaitForChild ( \"Util\" ): WaitForChild ( \"TweenUtil\" )) local DefaultColors = require ( Project : WaitForChild ( \"Data\" ): WaitForChild ( \"UI\" ): WaitForChild ( \"DefaultColors\" )) --[[ With Nexus Project. --]] --Create the base project. local NexusProject = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"NexusProject\" )) local Project = NexusProject . new ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"ClientModules\" )) --Require several modules. local UICreator = Project : GetResource ( \"UICreator\" ) local ColorUtil = Project : GetResource ( \"Util.ColorUtil\" ) local TweenUtil = Project : GetResource ( \"Util.TweenUtil\" ) local DefaultColors = Project : GetResource ( \"Data.UI.DefaultColors\" )","title":"Simplified Requires"},{"location":"why-nexus-project/#non-module-resources","text":"Along with ModuleScripts , other data can be retrieved or stored. This is useful for other Roblox instances, as well as configurable items or constants. --Create the base project. local NexusProject = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"NexusProject\" )) local Project = NexusProject . new ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"ClientModules\" )) --Store some values. Project : SetResource ( \"Constants.ConfirmColor\" , Color3 . new ( 0 , 1 , 0 )) Project : SetResource ( \"Constants.CancelColor\" , Color3 . new ( 1 , 0 , 0 )) --Get the values. local BaseButtonObject = Project : GetResource ( \"Base.UI.Buttton\" ) local ConfirmColor = Project : GetResource ( \"Constants.ConfirmColor\" ) local CancelColor = Project : GetResource ( \"Constants.CancelColor\" ) local ConfirmButtonBase , CancelButtonBase = BaseButtonObject : Clone (), BaseButtonObject : Clone () ConfirmButtonBase . BackgroundColor3 , CancelButtonBase . BackgroundColor3 = ConfirmColor , CancelColor","title":"Non-Module Resources"},{"location":"why-nexus-project/#custom-base-paths","text":"A project may store objects in different places. All of these can be combined into a single project. --Create the base project. local NexusProject = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"NexusProject\" )) local Project = NexusProject . new ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"ClientModules\" )) --Add external path bases. Project : CreatePathLink ( \"Workspace\" , game : GetService ( \"Workspace\" )) Project : CreatePathLink ( \"Common\" , game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"CommonModules\" )) --Get several resources. local Baseplate = Project : GetResource ( \"Workspace.Baseplate\" ) local Terrain = Project : GetResource ( \"Workspace.Terrain\" ) local CFrameTweenUtil = Project : GetResource ( \"Common.Util.CFrameTweenUtil\" )","title":"Custom Base Paths"},{"location":"why-nexus-project/#path-redirecting","text":"For public libraries, modules may need to be moved to make it more clear, or to refactor code. --Create the base project. local NexusProject = require ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"NexusProject\" )) local Project = NexusProject . new ( game : GetService ( \"ReplicatedStorage\" ): WaitForChild ( \"ClientModules\" )) --Redirect resources. Project : SetResource ( \"ColorUtil\" , Project : GetResource ( \"Util.ColorUtil\" )) Project : SetResource ( \"TweenUtil\" , Project : GetResource ( \"Util.TweenUtil\" ))","title":"Path Redirecting"},{"location":"why-nexus-project/#cyclic-dependency-detection-and-correction","text":"Cyclic dependency (A requires B, B requires A) happens a lot and can be hard to detect. Using \"contexts\", detecting them can be pretty easy. For example, assume there are the following scripts: --ReplicatedStorage/Client local NexusProject = require ( script : WaitForChild ( \"NexusProject\" )) local Client = NexusProject . new ( script ) return Client --ReplicatedStorage/Client/Util/ColorUtil local Client = require ( script . Parent . Parent ): GetContext ( script ) local TweenUtil = Client : GetResource ( \"Util.TweenUtil\" ) local ColorUtil = {} return ColorUtil --ReplicatedStorage/Client/Util/TweenUtil local Client = require ( script . Parent . Parent ): GetContext ( script ) local TeleportUtil = Client : GetResource ( \"Util.TeleportUtil\" ) local TweenUtil = {} return TweenUtil --ReplicatedStorage/Client/Util/TeleportUtil local Client = require ( script . Parent . Parent ): GetContext ( script ) local ColorUtil = Client : GetResource ( \"Util.ColorUtil\" ) local TeleportUtil = {} return TeleportUtil Would result in the following warning: A dependency loop exists : Util . ColorUtil Util . TweenUtil Util . TeleportUtil Util . ColorUtil Use NexusProject :: SetResource or NexusProjectContext :: SetContextResource to allow the loop to end without having to load the resources . The last line shows how it can be mitigated. All 3 modules end up in a deadlock since each need each other to finish loading to continue. The quick way to resolve this is to set one of the resources so the others can finish loading. --ReplicatedStorage/Client/Util/TweenUtil local Client = require ( script . Parent . Parent ): GetContext ( script ) local TweenUtil = {} Client : SetContextResource ( TweenUtil ) local TeleportUtil = Client : GetResource ( \"Util.TeleportUtil\" ) return TweenUtil","title":"Cyclic Dependency Detection and Correction"},{"location":"getting-started/intended-setup/","text":"Intended Setup For creating a library, it is not intended to require Nexus Project and set up the project for each use. The intended use is to have the root of a library set up the project and to require it externally. For example, a root ModuleScript for Nexus Git could look like this: --[[ TheNexusAvenger Root project for Nexus Git. --]] --Create the project. local NexusProject = require ( script : WaitForChild ( \"NexusProject\" )) local NexusGit = NexusProject . new ( script ) --Add some constants. NexusGit : SetResource ( \"Constants.NexusGit.Version\" , \"1.0.0\" ) NexusGit : SetResource ( \"Constants.NexusGit.DisplayName\" , \"Nexus Git\" ) --Add a custom method. function NexusGit : PrintVersion () print ( \"Nexus Git 1.0.0\" ) end --Return the project. return NexusGit A script using the project can use the project like the following: --[[ TheNexusAvenger Class that invokes actions. --]] local NexusGit = require ( script . Parent . Parent . Parent . Parent ) local NexusWrappedInstance = NexusGit : GetResource ( \"NexusPluginFramework.Base.NexusWrappedInstance\" ) local NexusCollapsableListFrame = NexusGit : GetResource ( \"NexusPluginFramework.UI.CollapsableList.NexusCollapsableListFrame\" ) local ActionIcon = NexusGit : GetResource ( \"UI.Frame.Action.ActionIcon\" ) ...","title":"Intended Setup"},{"location":"getting-started/intended-setup/#intended-setup","text":"For creating a library, it is not intended to require Nexus Project and set up the project for each use. The intended use is to have the root of a library set up the project and to require it externally. For example, a root ModuleScript for Nexus Git could look like this: --[[ TheNexusAvenger Root project for Nexus Git. --]] --Create the project. local NexusProject = require ( script : WaitForChild ( \"NexusProject\" )) local NexusGit = NexusProject . new ( script ) --Add some constants. NexusGit : SetResource ( \"Constants.NexusGit.Version\" , \"1.0.0\" ) NexusGit : SetResource ( \"Constants.NexusGit.DisplayName\" , \"Nexus Git\" ) --Add a custom method. function NexusGit : PrintVersion () print ( \"Nexus Git 1.0.0\" ) end --Return the project. return NexusGit A script using the project can use the project like the following: --[[ TheNexusAvenger Class that invokes actions. --]] local NexusGit = require ( script . Parent . Parent . Parent . Parent ) local NexusWrappedInstance = NexusGit : GetResource ( \"NexusPluginFramework.Base.NexusWrappedInstance\" ) local NexusCollapsableListFrame = NexusGit : GetResource ( \"NexusPluginFramework.UI.CollapsableList.NexusCollapsableListFrame\" ) local ActionIcon = NexusGit : GetResource ( \"UI.Frame.Action.ActionIcon\" ) ...","title":"Intended Setup"},{"location":"getting-started/classes/nexusproject/","text":"NexusProject (Extends NexusObject ) NexusProject is the root class for projects. When setting up a project, NexusProject 's constructor should be called like the other examples. static NexusProject.new(ReferenceInstance,SuppressCyclicWarnings) Creates an instance of Nexus Project. The ReferenceInstance is the root object of the project. SuppressCyclicWarnings can be sent to true to disable warnings about cyclic loading (ex: Script1 requires Script2, Script2 requires Script1). NexusProject:GetResource(Path) Returns the resource for the given path. If it is a ModuleScript, it is required and returned. NexusProject:SetResource(Path,Resource) Registers a resource with a given path. If GetResource is called, it will use what is registered. NexusProject:CreatePathLink(Reference,Object) Creates a link between a string and a game reference. Note that it will only be valid for the first word (ex: game in game.Workspace ) and the given string should NOT have a period. Also note that links are case sensitive. NexusProject:IsLoading(Path) Returns if a resource loading. NexusProject:GetContext(ScriptReference) Returns a NexusProjectContext for getting resources. The first parameter should be the script property. This is used for detecting and warning cyclic dependencies (A requires B, B requires A). NexusProject:IsInstanceInPath(Ins) Returns if an instance is part of the project. NexusProject:IsResourceCyclic(Path) Returns if a dependent eventually has itself as a dependent. NexusProject:GetObjectReference(Path) Returns the object reference for the given string. NexusProject:GetPathFromInstance(Ins) Returns the project path for the given instance. Throws an error if the instance isn't part of the project. NexusProject:GetDependencyPath(Dependent,Dependency,VisitiedDependents) Returns a table of the path from a dependent to a sub-dependent. Returns nil if the dependent doesn't have the dependency.","title":"NexusProject"},{"location":"getting-started/classes/nexusproject/#nexusproject","text":"(Extends NexusObject ) NexusProject is the root class for projects. When setting up a project, NexusProject 's constructor should be called like the other examples.","title":"NexusProject"},{"location":"getting-started/classes/nexusproject/#static-nexusprojectnewreferenceinstancesuppresscyclicwarnings","text":"Creates an instance of Nexus Project. The ReferenceInstance is the root object of the project. SuppressCyclicWarnings can be sent to true to disable warnings about cyclic loading (ex: Script1 requires Script2, Script2 requires Script1).","title":"static NexusProject.new(ReferenceInstance,SuppressCyclicWarnings)"},{"location":"getting-started/classes/nexusproject/#nexusprojectgetresourcepath","text":"Returns the resource for the given path. If it is a ModuleScript, it is required and returned.","title":"NexusProject:GetResource(Path)"},{"location":"getting-started/classes/nexusproject/#nexusprojectsetresourcepathresource","text":"Registers a resource with a given path. If GetResource is called, it will use what is registered.","title":"NexusProject:SetResource(Path,Resource)"},{"location":"getting-started/classes/nexusproject/#nexusprojectcreatepathlinkreferenceobject","text":"Creates a link between a string and a game reference. Note that it will only be valid for the first word (ex: game in game.Workspace ) and the given string should NOT have a period. Also note that links are case sensitive.","title":"NexusProject:CreatePathLink(Reference,Object)"},{"location":"getting-started/classes/nexusproject/#nexusprojectisloadingpath","text":"Returns if a resource loading.","title":"NexusProject:IsLoading(Path)"},{"location":"getting-started/classes/nexusproject/#nexusprojectgetcontextscriptreference","text":"Returns a NexusProjectContext for getting resources. The first parameter should be the script property. This is used for detecting and warning cyclic dependencies (A requires B, B requires A).","title":"NexusProject:GetContext(ScriptReference)"},{"location":"getting-started/classes/nexusproject/#nexusprojectisinstanceinpathins","text":"Returns if an instance is part of the project.","title":"NexusProject:IsInstanceInPath(Ins)"},{"location":"getting-started/classes/nexusproject/#nexusprojectisresourcecyclicpath","text":"Returns if a dependent eventually has itself as a dependent.","title":"NexusProject:IsResourceCyclic(Path)"},{"location":"getting-started/classes/nexusproject/#nexusprojectgetobjectreferencepath","text":"Returns the object reference for the given string.","title":"NexusProject:GetObjectReference(Path)"},{"location":"getting-started/classes/nexusproject/#nexusprojectgetpathfrominstanceins","text":"Returns the project path for the given instance. Throws an error if the instance isn't part of the project.","title":"NexusProject:GetPathFromInstance(Ins)"},{"location":"getting-started/classes/nexusproject/#nexusprojectgetdependencypathdependentdependencyvisitieddependents","text":"Returns a table of the path from a dependent to a sub-dependent. Returns nil if the dependent doesn't have the dependency.","title":"NexusProject:GetDependencyPath(Dependent,Dependency,VisitiedDependents)"},{"location":"getting-started/classes/nexusprojectcontext/","text":"NexusProjectContext (Extends NexusObject ) (Uses implemention of [NexusProject](nexusproject.md) ) NexusProjectContext is created by NexusProject::GetContext for warning about cyclic dependencies. All of the API except for the constructor is caried over from [NexusProject](nexusproject.md) . static NexusProjectContext.new(RequiringScript,Project) Creates a Nexus Project Context object. Not intended to be used outside of NexusProject::GetContext . NexusProjectContext:SetContextResource(Resource) Sets the resource for the given context.","title":"NexusProjectContext"},{"location":"getting-started/classes/nexusprojectcontext/#nexusprojectcontext","text":"(Extends NexusObject ) (Uses implemention of [NexusProject](nexusproject.md) ) NexusProjectContext is created by NexusProject::GetContext for warning about cyclic dependencies. All of the API except for the constructor is caried over from [NexusProject](nexusproject.md) .","title":"NexusProjectContext"},{"location":"getting-started/classes/nexusprojectcontext/#static-nexusprojectcontextnewrequiringscriptproject","text":"Creates a Nexus Project Context object. Not intended to be used outside of NexusProject::GetContext .","title":"static NexusProjectContext.new(RequiringScript,Project)"},{"location":"getting-started/classes/nexusprojectcontext/#nexusprojectcontextsetcontextresourceresource","text":"Sets the resource for the given context.","title":"NexusProjectContext:SetContextResource(Resource)"}]}